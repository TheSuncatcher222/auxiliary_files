"""
Существует несколько методик программирования:

    - ООП (объектно-ориентированное):
        - основана на концепции объектов, которые представляют собой
          набор данных и методов для работы с ними

    - процедурное:
        - программа состоит из процедур и функций, каждая
          из которых выполняет конкретную задачу
        - программы на C, где основной акцент на последовательном
          выполнении функций

    - функциональное:
        - основой являются функции, где логика выражается через их композицию
        - в Python это map, filter, reduse

    - декларативное:
        - описывает, что программа должна сделать, а не как
        - например, SQL

    - логическое и событийно ориентированное:
        - программирование через задание фактов и правил

    - модульное
        - программы разбиваются на независимые модули, которые выполняют
          конкретные функции и могут быть переиспользованы в разных проектах

    - TDD и BDD:
        - сначала разрабатываются тесты, а код пишется так, чтобы тесты проходили

    - асинхронное и событийно ориентированное:
        - программа реагирует на события, используя обработчики событий
"""

"""
Принципы ООП:

    - Абстракция:
        - принцип, который скрывает детали реализации и предоставляет
          только необходимые интерфейсы
        - класс Car, у которого есть метод start() - водителю не важно,
          как устроена система зажигания, важно, что машина заведется

    - наследование:
        - возможность одного класса (подкласса) унаследовать свойства и методы
          другого (родительского)
        - класс Vehicle, и подкласс Car, который наследует свойства и методы,
          но может добавлять свои уникальные свойств и методы

    - инкапсуляция:
        - механизм скрытия внутренней реализации объекта и защиты данных
          от внешнего вмешательства. Реализуется через модификаторы доступа
          (приватные и публичные переменные)
        - чтобы получить доступ к этим данным используются публичные методы
          (геттер и сеттер)
        - нужно для:
            - защиты данных от случайного изменения
            - контроля доступа
        - у класса BancAccount есть приватный атрибут __balance,
          который нельзя вызвать напрямую и модифицировать, но есть публичные
          методы add(), get(), deposit()

    - полиморфизм:
        - возможность использовать один и тот же метод или интерфейс
          для разных объектов
        - метод speak() может быть реализован в классе Dog и Cat,
          но в первом случае выводит "Гав", во втором "Мяу"
"""


from abc import (
    ABC,
    abstractclassmethod,
)


# -----------------------------------------------------------------------------


class Parent:
    def __init__(self, name) -> None:
        self.name = name

class Child(Parent):
    def __init__(self, name, parent_name) -> None:
        super().__init__(parent_name)


# -----------------------------------------------------------------------------


class AbstractClass(ABC):

    @abstractclassmethod
    def some_abstract_method(self):
        ...


"""
Классовые методы.
"""


# @staticmethod – используется для создания метода,
# который ничего не знает о классе или экземпляре,через который он был вызван.
# Он просто получает переданные аргументы, без неявного первого аргумента,
# и его определение неизменяемо через наследование.


class Person():

    @staticmethod
    def is_adult(age):
        if age > 18:
            print(True)
        else:
            print(False)


ron = Person()
ron.is_adult(23)


# @classmethod – это метод, который получает класс в качестве неявного
# первого аргумента, точно так же, как обычный метод экземпляра
# получает экземпляр. Это означает, что вы можете использовать класс
# и его свойства внутри этого метода, а не конкретного экземпляра.

from datetime import date


class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def fromBirthYear(cls, name, birthYear):
        return cls(name, date.today().year - birthYear)

    def display(self):
        print(self.name + "'s age is: " + str(self.age))


person = Person('Adam', 19)
person.display()

person1 = Person.fromBirthYear('John',  1985)
person1.display()


###

class Student:
    def __init__(self):
        self._score = 0

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, s):
        if 0 <= s <= 100:
            self._score = s
        else:
            raise ValueError('The score must be between 0 ~ 100!')

Yang = Student()

Yang.score=99
print(Yang.score)
# 99
# Yang.score = 999
# ValueError: The score must be between 0 ~ 100!


"""
Метаклассы - это классы, которые определяют поведение других классов.
Они используются для изменения способа, которым Python создает и обрабатывает классы.
Метаклассы могут быть полезны в следующих случаях:
    - при необходимости динамического изменения поведения класса, например,
    - если вы хотите добавить или удалить атрибут или метод класса во время выполнения программы.
    - при создании классов из данных, которые не заранее известны. 
      Например, вы можете создавать классы на основе определенных условий во время выполнения программы.
    - Для создания фреймворков и библиотек, которые нужно настраивать
      под конкретные требования и при этом сохранить простоту интерфейса.
      Они также могут использоваться для создания классов с определенными свойствами,
      например, классов, которые автоматически регистрируются в библиотеке
      или классов, которые автоматически сериализуются и десериализуются для совместимости с другими системами.
"""


class MyMeta(type):
    def __new__(cls, name, bases, dct):
        dct['my_attribute'] = 42
        return super(MyMeta, cls).__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass

print(MyClass.my_attribute)
